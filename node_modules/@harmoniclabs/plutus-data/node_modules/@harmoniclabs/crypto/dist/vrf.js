"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.vrf_ed25519_sha512_ell2_challenge_generation = exports.vrf_ed25519_sha512_ell2_nonce_generation = exports.vrf_ed25519_sha512_ell2_hash_to_curve = exports.vrf_ed25519_sha512_ell2_prove = void 0;
var ed25519_1 = require("./ed25519.js");
var sha2_512_1 = require("./sha2_512.js");
/**
4.4. RSA-FDH-VRF Ciphersuites

This document defines RSA-FDH-VRF-SHA256 as follows:

suite_string = 0x01.
The hash function Hash is SHA-256 as specified in [RFC6234], with hLen = 32.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

This document defines RSA-FDH-VRF-SHA384 as follows:

suite_string = 0x02.
The hash function Hash is SHA-384 as specified in [RFC6234], with hLen = 48.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

This document defines RSA-FDH-VRF-SHA512 as follows:

suite_string = 0x03.
The hash function Hash is SHA-512 as specified in [RFC6234], with hLen = 64.
MGF_salt = I2OSP(k, 4) || I2OSP(n, k).

 */
var SUITE = 0x03;
var ONE = 0x01;
var TWO = 0x02;
/**
 * https://datatracker.ietf.org/doc/html/rfc9381#section-5.1
 */
function vrf_ed25519_sha512_ell2_prove(sk, alpha) {
    var _a = __read((0, ed25519_1.extendEd25519PrivateKey)(sk), 2), scalar = _a[0], extension = _a[1];
    // 1. Use SK to derive the VRF secret scalar x and the VRF public key Y = x*B
    var pk = new Uint8Array((0, ed25519_1.deriveEd25519PublicKey)(Array.from(sk)));
    var H = vrf_ed25519_sha512_ell2_hash_to_curve(pk, alpha);
    var H_point = (0, ed25519_1.pointFromBytes)(H);
    var gamma = (0, ed25519_1.scalarMul)(H_point, scalar);
    var compressed_gamma = (0, ed25519_1.bigpointToUint8Array)(gamma);
    var k = vrf_ed25519_sha512_ell2_nonce_generation(extension, H);
    var announcement_1 = (0, ed25519_1.bigpointToUint8Array)((0, ed25519_1.scalarMultBase)(k));
    var announcement_2 = (0, ed25519_1.bigpointToUint8Array)((0, ed25519_1.scalarMul)(H_point, k));
    var challange = (0, ed25519_1.scalarFromBytes)(vrf_ed25519_sha512_ell2_challenge_generation(H, compressed_gamma, announcement_1, announcement_2));
    var response = k + challange * scalar;
    return {
        gamma: gamma,
        challange: challange,
        response: response
    };
}
exports.vrf_ed25519_sha512_ell2_prove = vrf_ed25519_sha512_ell2_prove;
function vrf_ed25519_sha512_ell2_hash_to_curve(public_key, alpha_string) {
    var input = new Uint8Array(2 + public_key.length + alpha_string.length);
    input[0] = SUITE;
    input[1] = ONE;
    input.set(public_key, 2);
    input.set(alpha_string, 2 + public_key.length);
    //return pointFromBytes(sha2_512(input))
    return (0, sha2_512_1.sha2_512)(input);
}
exports.vrf_ed25519_sha512_ell2_hash_to_curve = vrf_ed25519_sha512_ell2_hash_to_curve;
function vrf_ed25519_sha512_ell2_nonce_generation(secret_extension, H) {
    var input = new Uint8Array(64);
    input.set(secret_extension, 0);
    input.set(H, 32);
    //return pointFromBytes(sha2_512(input))
    return (0, ed25519_1.scalarFromBytes)((0, sha2_512_1.sha2_512)(input));
}
exports.vrf_ed25519_sha512_ell2_nonce_generation = vrf_ed25519_sha512_ell2_nonce_generation;
function vrf_ed25519_sha512_ell2_challenge_generation(H, gamma, announcement_1, announcement_2) {
    var input = new Uint8Array(2 + H.length + gamma.length + announcement_1.length + announcement_2.length);
    input[0] = SUITE;
    input[1] = TWO;
    input.set(H, 2);
    input.set(gamma, 2 + H.length);
    input.set(announcement_1, 2 + H.length + gamma.length);
    input.set(announcement_2, 2 + H.length + gamma.length + announcement_1.length);
    return (0, sha2_512_1.sha2_512)(input).slice(0, 16);
}
exports.vrf_ed25519_sha512_ell2_challenge_generation = vrf_ed25519_sha512_ell2_challenge_generation;
